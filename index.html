<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flumgus Tower Defense</title>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden;
    background: radial-gradient(ellipse at center, #87ceeb 0%, #4682b4 50%, #2e5f3e 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select:none;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  #gameContainer {
    flex: 1;
    position: relative;
    display: flex;
  }
  #gameCanvas {
    background: linear-gradient(135deg, #98fb98 0%, #90ee90 50%, #7cfc00 100%);
    display: block;
    border: 4px solid #2f4f2f;
    cursor: crosshair;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
  }
  #sidebar {
    width: 220px;
    background: linear-gradient(180deg, #2d2d2d 0%, #1a1a1a 100%);
    color: white;
    padding: 20px;
    overflow-y: auto;
    border-left: 3px solid #444;
    box-shadow: -5px 0 15px rgba(0,0,0,0.3);
  }
  #ui {
    background: linear-gradient(90deg, #333 0%, #2a2a2a 100%);
    color: white;
    padding: 15px;
    text-align: center;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 3px solid #444;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  }
  .tower-btn {
    display: block;
    width: 100%;
    margin: 10px 0;
    padding: 12px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 11px;
    cursor: pointer;
    border: 2px solid #555;
    background: linear-gradient(135deg, #444 0%, #333 100%);
    color: white;
    border-radius: 8px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }
  .tower-btn:hover {
    background: linear-gradient(135deg, #555 0%, #444 100%);
    border-color: #777;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }
  .tower-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
  }
  #gameInfo {
    text-align: left;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  }
  #waveInfo {
    margin: 20px 0;
    padding: 15px;
    background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%);
    border-radius: 8px;
    border: 1px solid #333;
  }
  button {
    font-family: 'Segoe UI', sans-serif;
    padding: 10px 18px;
    font-size: 14px;
    cursor: pointer;
    margin: 0 5px;
    border: 2px solid #555;
    background: linear-gradient(135deg, #4a4a4a 0%, #3a3a3a 100%);
    color: white;
    border-radius: 6px;
    transition: all 0.2s ease;
  }
  button:hover {
    background: linear-gradient(135deg, #5a5a5a 0%, #4a4a4a 100%);
    transform: translateY(-1px);
  }
  .selected-tower {
    background: linear-gradient(135deg, #666 0%, #555 100%) !important;
    border-color: #aaa !important;
    transform: translateY(-2px);
    box-shadow: 0 0 15px rgba(170, 170, 170, 0.5);
  }
  .tower-stats {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
    font-size: 9px;
    opacity: 0.8;
  }
  #particles {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 1000;
  }
</style>
</head>
<body>

<div id="ui">
  <div id="gameInfo">
    <div>üíö Health: <span id="health">25</span> ¬†|¬† ü•¨ Lettuce Currency: <span id="money">120</span></div>
    <div>Wave: <span id="wave">1</span> ¬†|¬† Score: <span id="score">0</span> ¬†|¬† Kills: <span id="kills">0</span></div>
  </div>
  <div>
    <button id="startWaveBtn">Start Wave</button>
    <button id="pauseBtn">Pause</button>
    <button id="speedBtn">Speed: 1x</button>
    <button id="sellBtn">Sell Mode</button>
  </div>
</div>

<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <div id="sidebar">
    <h3>üêå Elite Snail Defense Corps</h3>
    <!-- Tower buttons -->
    <button class="tower-btn" id="basicTower">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
          <strong>Normal Snail üêå</strong><br>
          <small>Steady and reliable defender</small>
        </div>
        <div style="text-align: right;"><div>üí∞ 25 ü•¨</div></div>
      </div>
      <div class="tower-stats">
        <span>‚öîÔ∏è 30 DMG</span>
        <span>üéØ 85 Range</span>
        <span>‚ö° 1.0 Speed</span>
      </div>
    </button>
    <button class="tower-btn" id="speedTower">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
          <strong>Turbo Snail üèéÔ∏è</strong><br>
          <small>Lightning-fast rapid fire</small>
        </div>
        <div style="text-align: right;"><div>üí∞ 50 ü•¨</div></div>
      </div>
      <div class="tower-stats">
        <span>‚öîÔ∏è 15 DMG</span>
        <span>üéØ 75 Range</span>
        <span>‚ö° 2 Speed</span>
      </div>
    </button>
    <button class="tower-btn" id="splashTower">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
          <strong>Slime Bomber üü¢</strong><br>
          <small>Explosive area damage</small>
        </div>
        <div style="text-align: right;"><div>üí∞ 70 ü•¨</div></div>
      </div>
      <div class="tower-stats">
        <span>‚öîÔ∏è 50 DMG</span>
        <span>üéØ 95 Range</span>
        <span>‚ö° 0.8 Speed</span>
      </div>
    </button>
    <button class="tower-btn" id="slowTower">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
          <strong>Frost Shell üßä</strong><br>
          <small>Freezing crowd control</small>
        </div>
        <div style="text-align: right;"><div>üí∞ 55 ü•¨</div></div>
      </div>
      <div class="tower-stats">
        <span>‚öîÔ∏è 25 DMG</span>
        <span>üéØ 90 Range</span>
        <span>‚ö° 1.3 Speed</span>
      </div>
    </button>
    <button class="tower-btn" id="laserTower">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
          <strong>Prism Snail üåà</strong><br>
          <small>Piercing laser beam</small>
        </div>
        <div style="text-align: right;"><div>üí∞ 15000 ü•¨</div></div>
      </div>
      <div class="tower-stats">
        <span>‚öîÔ∏è 450 DMG</span>
        <span>üéØ 300 Range</span>
        <span>‚ö° 5 Speed</span>
      </div>
    </button>
    <button class="tower-btn" id="poisonTower">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
          <strong>Toxic Spiral üíö</strong><br>
          <small>Damage over time</small>
        </div>
        <div style="text-align: right;"><div>üí∞ 65 ü•¨</div></div>
      </div>
      <div class="tower-stats">
        <span>‚öîÔ∏è 15+20 DMG</span>
        <span>üéØ 80 Range</span>
        <span>‚ö° 1.2 Speed</span>
      </div>
    </button>

    <div id="waveInfo">
      <h4>üìä Next Wave Preview:</h4>
      <div id="wavePreview">Click Start Wave!</div>
    </div>

    <div style="margin-top: 20px; font-size: 11px; color: #bbb; line-height: 1.4;">
      <p>üéØ <strong>Strategy Tips:</strong></p>
      <p>‚Ä¢ Mix different snail types for optimal defense</p>
      <p>‚Ä¢ Use Frost Shells to slow down fast enemies</p>
      <p>‚Ä¢ Slime Bombers excel against groups</p>
      <p>‚Ä¢ Prism Snails can hit multiple targets</p>
    </div>
  </div>
</div>

<script>
(async () => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Define sprite paths based on your description
  const spritePaths = {
    basic: 'snail1.png',
    speed: 'turbosnail.png',
    splash: 'slimesnail.png',
    slow: 'frostsnail.png',
    laser: 'prismsnail.png',
    poison: 'acidsnail.png'
  };
  const sprites = {};

  // Load all sprites before starting game
  const loadSprites = () => {
    const promises = Object.entries(spritePaths).map(([key, src]) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = src;
        img.onload = () => {
          sprites[key] = img;
          resolve();
        };
        img.onerror = reject;
      });
    });
    return Promise.all(promises);
  };

  // All your existing code (variables, classes, functions) goes here...

  let gameRunning = false;
  let gamePaused = false;
  let gameSpeed = 1;
  let money = 120;
  let health = 25;
  let wave = 1;
  let score = 0;
  let kills = 0;
  let selectedTowerType = null;
  let sellMode = false;

  let towers = [];
  let enemies = [];
  let projectiles = [];
  let particles = [];
  let effects = [];

  let mouseX = 0;
  let mouseY = 0;

  // Path
  const path = [
    {x: -50, y: 120}, {x: 100, y: 120}, {x: 140, y: 80},
    {x: 200, y: 80}, {x: 240, y: 120}, {x: 300, y: 120},
    {x: 340, y: 160}, {x: 400, y: 160}, {x: 440, y: 200},
    {x: 500, y: 200}, {x: 540, y: 240}, {x: 600, y: 240},
    {x: 640, y: 280}, {x: 700, y: 280}, {x: 740, y: 320},
    {x: 800, y: 320}, {x: 850, y: 360}
  ];

  // Tower types
  const towerTypes = {
    basic: { 
      cost: 25, damage: 30, range: 85, speed: 1.0,
      emoji: 'üêå', color: '#8B4513', bgColor: '#654321', name: 'Normal Snail', effect: 'basic'
    },
    speed: { 
      cost: 50, damage: 15, range: 75, speed: 20,
      emoji: 'üêå', color: '#ff4444', bgColor: '#cc3333', name: 'Turbo Snail', effect: 'basic'
    },
    splash: { 
      cost: 70, damage: 50, range: 95, speed: 0.8,
      emoji: 'üêå', color: '#00ff00', bgColor: '#00cc00', name: 'Slime Bomber', effect: 'splash'
    },
    slow: { 
      cost: 55, damage: 25, range: 90, speed: 1.3,
      emoji: 'üêå', color: '#00ffff', bgColor: '#00cccc', name: 'Frost Shell', effect: 'slow'
    },
    laser: {
      cost: 15000, damage: 450, range: 300, speed: 5,
      emoji: 'üêå', color: '#ff00ff', bgColor: '#cc00cc', name: 'Prism Snail', effect: 'pierce'
    },
    poison: {
      cost: 65, damage: 15, range: 80, speed: 1.2,
      emoji: 'üêå', color: '#99ff99', bgColor: '#66cc66', name: 'Toxic Spiral', effect: 'poison'
    }
  };

  // Enemy types
  const enemyTypes = {
    basic: { health: 65, speed: 1, reward: 10, emoji: 'üêõ', name: 'Garden Bug' },
    fast: { health: 39, speed: 2.2, reward: 12, emoji: 'üêú', name: 'Speed Ant' },
    tank: { health: 350, speed: 0.6, reward: 20, emoji: 'ü™≤', name: 'Armored Beetle' },
    boss: { health: 420, speed: 0.8, reward: 30, emoji: 'ü¶Ç', name: 'Scorpion Boss' },
    flying: { health: 85, speed: 1.8, reward: 12, emoji: 'ü¶ü', name: 'Buzz Mosquito' },
    worm: { health: 150, speed: 0.9, reward: 15, emoji: 'ü™±', name: 'Earth Worm' },
    spider: { health: 100, speed: 1.4, reward: 15, emoji: 'üï∑Ô∏è', name: 'Web Spider' },
    mega: { health: 5000, speed: 0.5, reward: 200, emoji: 'üêâ', name: 'Mega Dragon' },
    swarm: { health: 25, speed: 2.5, reward: 2, emoji: 'ü¶ó', name: 'Swarm Locust' },
    shield: { health: 120, speed: 1.1, reward: 20, emoji: 'üõ°Ô∏è', name: 'Shield Bug' }
  };

  class Tower {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.type = type;
      this.lastShot = 0;
      this.target = null;
      this.kills = 0;
      this.totalDamage = 0;
      this.level = 1;
    }

    update(now) {
      const towerData = towerTypes[this.type];
      if (now - this.lastShot < 1000 / (towerData.speed * this.level * 0.1 + towerData.speed)) return;

      let target = this.findTarget();
      if (target) {
        this.shoot(target, now);
        this.lastShot = now;
      }
    }

    findTarget() {
      const towerData = towerTypes[this.type];
      let bestTarget = null;
      let bestValue = -1;

      enemies.forEach(enemy => {
        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
        if (dist <= towerData.range) {
          let value = 0;
          switch(this.type) {
            case 'speed':
              value = 1000 - dist; // Closest first
              break;
            case 'splash':
              let nearbyCount = enemies.filter(e => 
                Math.hypot(e.x - enemy.x, e.y - enemy.y) <= 60
              ).length;
              value = nearbyCount * 100 - dist;
              break;
            case 'slow':
              value = enemy.speed * 100 - dist; // Fast enemies first
              break;
            default:
              value = enemy.health - dist; // Strongest first
          }
          if (value > bestValue) {
            bestValue = value;
            bestTarget = enemy;
          }
        }
      });
      return bestTarget;
    }

    shoot(target, now) {
      const towerData = towerTypes[this.type];
      const damage = towerData.damage + (this.level - 1) * 5;

      projectiles.push({
        x: this.x,
        y: this.y,
        targetX: target.x,
        targetY: target.y,
        target: target,
        damage: damage,
        speed: 10,
        type: this.type,
        createdAt: now,
        tower: this
      });

      effects.push({
        x: this.x,
        y: this.y,
        type: 'muzzleFlash',
        color: towerData.projectileColor,
        life: 10,
        maxLife: 10
      });
    }

    getSellValue() {
      return Math.floor(towerTypes[this.type].cost * 0.7 * this.level);
    }

    draw() {
      const towerData = towerTypes[this.type];

      // Range circle
      if ((selectedTowerType === this.type && !sellMode) || sellMode) {
        ctx.strokeStyle = sellMode ? '#ff6666' : towerData.color + '44';
        ctx.lineWidth = 2;
        ctx.setLineDash(sellMode ? [5, 5] : []);
        ctx.beginPath();
        ctx.arc(this.x, this.y, towerData.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw background pattern
      this.drawBackground(towerData);

      // Draw sprite scaled to 50px height
      const sprite = sprites[this.type];
      if (sprite) {
        const targetHeight = 50;
        const scale = targetHeight / sprite.height;
        const width = sprite.width * scale;
        const height = sprite.height * scale;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.drawImage(sprite, -width/2, -height/2, width, height);
        ctx.restore();
      }

      ctx.strokeStyle = towerData.bgColor;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 16, 0, Math.PI * 2);
      ctx.stroke();

      if (this.level > 1) {
        ctx.fillStyle = '#ffd700';
        ctx.font = '10px bold sans-serif';
        ctx.textAlign='center';
        ctx.fillText('‚òÖ'.repeat(this.level - 1), this.x, this.y + 28);
      }

      if (sellMode) {
        ctx.fillStyle = '#ffff00';
        ctx.font = '12px bold sans-serif';
        ctx.textAlign='center';
        ctx.fillText('üí∞' + this.getSellValue(), this.x, this.y - 35);
      }
    }

    drawBackground(towerData) {
      ctx.save();
      switch(this.type) {
        case 'basic':
          ctx.fillStyle = '#8B7355';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y + 5, 25, 12, 0, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'speed':
          ctx.strokeStyle = '#ff9999';
          ctx.lineWidth = 3;
          for(let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.moveTo(this.x - 15 + i * 8, this.y - 15);
            ctx.lineTo(this.x + 15 + i * 8, this.y + 15);
            ctx.stroke();
          }
          break;
        case 'splash':
          ctx.fillStyle = '#66ff6644';
          ctx.beginPath();
          ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#66ff6666';
          ctx.beginPath();
          ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'slow':
          ctx.strokeStyle = '#66ffff';
          ctx.lineWidth = 2;
          for(let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const x = this.x + Math.cos(angle) * 15;
            const y = this.y + Math.sin(angle) * 15;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(this.x + Math.cos(angle) * 25, this.y + Math.sin(angle) * 25);
            ctx.stroke();
          }
          break;
        case 'laser':
          const prismGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 30);
          prismGradient.addColorStop(0, '#ffffff44');
          prismGradient.addColorStop(0.5, '#ff66ff22');
          prismGradient.addColorStop(1, '#6666ff11');
          ctx.fillStyle = prismGradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'poison':
          ctx.fillStyle = '#99ff9933';
          for(let i=0; i<5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const x = this.x + Math.cos(angle) * 20;
            const y = this.y + Math.sin(angle) * 20;
            ctx.beginPath();
            ctx.arc(x, y, 4 + Math.sin(performance.now() * 0.01 + i) * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
      }
      ctx.restore();
    }
  }

  class Enemy {
    constructor(type, pathIndex=0) {
      this.type = type;
      this.maxHealth = enemyTypes[type].health * (1 + wave*0.1);
      this.health = this.maxHealth;
      this.speed = enemyTypes[type].speed;
      this.reward = enemyTypes[type].reward;
      this.pathIndex = pathIndex;
      this.x = path[0].x;
      this.y = path[0].y;
      this.slowEffect = 1;
      this.slowUntil = 0;
      this.poisonDamage = 0;
      this.poisonUntil = 0;
      this.shields = this.type === 'shield' ? 2 : 0;
    }

    update(now) {
      if (now > this.slowUntil) this.slowEffect = 1;
      if (now < this.poisonUntil && now % 500 < 16) {
        this.takeDamage(this.poisonDamage, 'poison');
      }
      const currentSpeed = this.speed * this.slowEffect * gameSpeed;
      if (this.pathIndex < path.length - 1) {
        const current = path[this.pathIndex];
        const next = path[this.pathIndex + 1];
        const dx = next.x - current.x;
        const dy = next.y - current.y;
        const distance = Math.hypot(dx, dy);
        if (distance > 0) {
          const moveX = (dx / distance) * currentSpeed;
          const moveY = (dy / distance) * currentSpeed;
          this.x += moveX;
          this.y += moveY;
          if (Math.hypot(next.x - this.x, next.y - this.y) < currentSpeed) {
            this.pathIndex++;
            if (this.pathIndex < path.length) {
              this.x = path[this.pathIndex].x;
              this.y = path[this.pathIndex].y;
            }
          }
        }
      }
    }

    takeDamage(damage, effectType='basic') {
      let actualDamage = damage;
      if (this.shields > 0 && effectType !== 'poison') {
        this.shields--;
        actualDamage *= 0.5;
        effects.push({x:this.x, y:this.y, type:'shieldBreak', life:30, maxLife:30});
      }
      this.health -= actualDamage;
      if (effectType === 'slow') {
        this.slowEffect = 0.4;
        this.slowUntil = performance.now() + 3000;
      } else if (effectType === 'poison') {
        this.poisonDamage = Math.max(this.poisonDamage, damage*0.5);
        this.poisonUntil = performance.now() + 4000;
      }
      // Particle damage text
      particles.push({x:this.x+(Math.random()-0.5)*20, y:this.y-25, text:'-' + Math.floor(actualDamage), life:60, color: (effectType==='poison') ? '#99ff99' : '#ffff00', vx:(Math.random()-0.5)*2, vy:-2});
      return this.health <= 0;
    }

    reachedEnd() {
      return this.pathIndex >= path.length-1 && this.x >= path[path.length-1].x;
    }

    draw() {
      // Effects like slow, poison, shields
      if (this.slowEffect < 1) {
        ctx.fillStyle = '#00ffff33';
        ctx.beginPath(); ctx.arc(this.x, this.y, 20, 0, Math.PI*2); ctx.fill();
      }
      if (this.poisonDamage > 0) {
        ctx.fillStyle = '#99ff9933';
        ctx.beginPath(); ctx.arc(this.x, this.y, 18, 0, Math.PI*2); ctx.fill();
      }
      if (this.shields > 0) {
        ctx.strokeStyle = '#4444ff';
        ctx.lineWidth = 3;
        ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.arc(this.x, this.y, 22, 0, Math.PI*2); ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw enemy sprite scaled to size
      const enemyData = enemyTypes[this.type];
      const size = (this.type==='mega') ? 36 : (this.type==='boss') ? 32 : 28;
      const sprite = sprites[this.type];
      if (sprite) {
        const targetHeight = size;
        const scale = targetHeight / sprite.height;
        const width = sprite.width * scale;
        const height = sprite.height * scale;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.drawImage(sprite, -width/2, -height/2, width, height);
        ctx.restore();
      } else {
        ctx.font = size + 'px serif';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(enemyData.emoji, this.x, this.y);
      }

      // Health bar
      const barWidth = 35;
      const barHeight=5;
      const healthPercent = this.health / this.maxHealth;
      ctx.fillStyle='#000';
      ctx.fillRect(this.x - barWidth/2 -1, this.y -30 -1, barWidth+2, barHeight+2);
      ctx.fillStyle='#f00';
      ctx.fillRect(this.x - barWidth/2, this.y -30, barWidth, barHeight);
      ctx.fillStyle= healthPercent > 0.6 ? '#0f0' : healthPercent >0.3 ? '#ff0' : '#f44';
      ctx.fillRect(this.x - barWidth/2, this.y -30, barWidth*healthPercent, barHeight);

      if (this.shields > 0) {
        ctx.fillStyle='#4444ff';
        ctx.font='12px sans-serif';
        ctx.fillText('üõ°Ô∏è'.repeat(this.shields), this.x, this.y -40);
      }
    }
  }

  // Update projectiles
  function updateProjectiles(now) {
    projectiles = projectiles.filter(proj => {
      const dx = proj.targetX - proj.x;
      const dy = proj.targetY - proj.y;
      const distance = Math.hypot(dx, dy);
      if (distance < proj.speed || now - proj.createdAt > 3000) {
        if (proj.target && enemies.includes(proj.target)) {
          handleProjectileHit(proj);
        }
        return false;
      }
      // move projectile
      proj.x += (dx / distance) * proj.speed;
      proj.y += (dy / distance) * proj.speed;
      if (proj.target && enemies.includes(proj.target)) {
        proj.targetX = proj.target.x;
        proj.targetY = proj.target.y;
      }
      return true;
    });
  }

  function handleProjectileHit(proj) {
    const killed = proj.target.takeDamage(proj.damage, proj.type);
    switch(proj.type) {
      case 'splash':
        enemies.forEach(enemy => {
          if (enemy !== proj.target) {
            const dist = Math.hypot(enemy.x - proj.target.x, enemy.y - proj.target.y);
            if (dist <= 60) enemy.takeDamage(proj.damage * 0.6, 'splash');
          }
        });
        effects.push({x:proj.target.x, y:proj.target.y, type:'explosion', color:'#00ff00', life:30, maxLife:30});
        break;
      case 'laser':
        const lineX1=proj.x, lineY1=proj.y, lineX2=proj.targetX, lineY2=proj.targetY;
        const line = {x1: lineX1, y1: lineY1, x2: lineX2, y2: lineY2};
        const pierceTargets = enemies.filter(e => {
          if (e===proj.target) return false;
          const dist = distanceToLine(e.x, e.y, line.x1, line.y1, line.x2, line.y2);
          return dist < 15;
        });
        pierceTargets.forEach(e => e.takeDamage(proj.damage*0.8, 'pierce'));
        break;
      case 'poison':
        proj.target.poisonDamage = Math.max(proj.target.poisonDamage, proj.damage*0.3);
        proj.target.poisonUntil = performance.now() + 5000;
        break;
    }
    if (killed) {
      score += proj.target.reward;
      money += proj.target.reward;
      kills++;
      proj.tower.kills++;
      proj.tower.totalDamage += proj.damage;
      // Upgrade tower after certain kills
      if (proj.tower.kills >= 10 * proj.tower.level && proj.tower.level < 3) {
        proj.tower.level++;
        effects.push({x:proj.tower.x, y:proj.tower.y, type:'levelUp', life:60, maxLife:60});
      }
      updateUI();
    }
  }

  function distanceToLine(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    if (lenSq !== 0) param = dot / lenSq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function drawProjectiles() {
    projectiles.forEach(proj => {
      const towerData = towerTypes[proj.type];
      if (proj.type === 'laser') {
        ctx.strokeStyle = towerData.projectileColor;
        ctx.lineWidth=3;
        ctx.beginPath();
        ctx.moveTo(proj.x, proj.y);
        ctx.lineTo(proj.targetX, proj.targetY);
        ctx.stroke();
        ctx.strokeStyle = towerData.projectileColor + '44';
        ctx.lineWidth=6;
        ctx.stroke();
      } else {
        ctx.fillStyle = towerData.projectileColor;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.type==='splash'?5:4, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = towerData.projectileColor + '66';
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.type==='splash'?8:6, 0, Math.PI*2);
        ctx.fill();
      }
    });
  }

  function updateParticles() {
    particles = particles.filter(p => {
      p.x += p.vx || 0;
      p.y += p.vy || -1;
      p.life--;
      return p.life > 0;
    });
  }

  function drawParticles() {
    particles.forEach(p => {
      const alpha = p.life / 60;
      ctx.fillStyle = p.color + Math.floor(alpha*255).toString(16).padStart(2,'0');
      ctx.font = '14px bold sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.text, p.x, p.y);
    });
  }

  function updateEffects() {
    effects = effects.filter(e => {
      e.life--;
      return e.life > 0;
    });
  }

  function drawEffects() {
    effects.forEach(e => {
      const alpha = e.life / e.maxLife;
      switch(e.type) {
        case 'explosion':
          ctx.fillStyle = e.color + Math.floor(alpha*100).toString(16).padStart(2,'0');
          ctx.beginPath();
          ctx.arc(e.x, e.y, (1-alpha)*50, 0, Math.PI*2);
          ctx.fill();
          break;
        case 'muzzleFlash':
          ctx.fillStyle = e.color + Math.floor(alpha*200).toString(16).padStart(2,'0');
          ctx.beginPath();
          ctx.arc(e.x, e.y, alpha*8, 0, Math.PI*2);
          ctx.fill();
          break;
        case 'levelUp':
          ctx.fillStyle = '#ffd700' + Math.floor(alpha*255).toString(16).padStart(2,'0');
          ctx.font = (20 + (1-alpha)*10) + 'px bold sans-serif';
          ctx.textAlign='center';
          ctx.fillText('LEVEL UP!', e.x, e.y - 40);
          break;
        case 'shieldBreak':
          ctx.strokeStyle = '#4444ff' + Math.floor(alpha*255).toString(16).padStart(2,'0');
          ctx.lineWidth=3;
          ctx.beginPath();
          ctx.arc(e.x, e.y, alpha*25, 0, Math.PI*2);
          ctx.stroke();
          break;
      }
    });
  }

  function drawPath() {
    ctx.strokeStyle = '#654321';
    ctx.lineWidth = 24;
    ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i=1; i<path.length; i++) {
      ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();

    ctx.strokeStyle = '#8B7355';
    ctx.lineWidth=18;
    ctx.stroke();

    ctx.strokeStyle = '#A0522D';
    ctx.lineWidth=2;
    ctx.setLineDash([10,5]);
    ctx.stroke();
    ctx.setLineDash([]);

    // End farm area
    const farmX=path[path.length-1].x;
    const farmY=path[path.length-1].y;
    ctx.fillStyle='#8B4513';
    ctx.fillRect(farmX-25,farmY-15,50,30);
    ctx.font='45px serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('ü•¨', farmX, farmY);
    ctx.fillStyle='#654321';
    ctx.fillRect(farmX-35, farmY-40,70,20);
    ctx.fillStyle='#fff';
    ctx.font='12px bold sans-serif';
    ctx.fillText('LETTUCE FARM', farmX, farmY-30);
  }

  function drawGhostTower(x,y) {
    if (!selectedTowerType || sellMode) return;
    let validPosition = true;
    for (let p of path) {
      if (Math.hypot(x - p.x, y - p.y) < 45) { validPosition = false; break; }
    }
    for (let t of towers) {
      if (Math.hypot(x - t.x, y - t.y) < 40) { validPosition = false; break; }
    }
    const canAfford = money >= towerTypes[selectedTowerType].cost;
    const alpha = validPosition && canAfford ? '88' : '44';
    const color = validPosition && canAfford ? towerTypes[selectedTowerType].color : '#ff0000';

    ctx.strokeStyle = color + '33';
    ctx.lineWidth=2;
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.arc(x, y, towerTypes[selectedTowerType].range, 0, Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw sprite as ghost (scaled)
    const sprite = sprites[selectedTowerType];
    if (sprite) {
      const targetHeight=50;
      const scale= targetHeight / sprite.height;
      const width = sprite.width * scale;
      const height= sprite.height * scale;
      ctx.save();
      ctx.translate(x,y);
      ctx.globalAlpha=0.4;
      ctx.drawImage(sprite, -width/2, -height/2, width, height);
      ctx.globalAlpha=1;
      ctx.restore();
    }

    ctx.fillStyle = canAfford ? '#00ff00' : '#ff0000';
    ctx.font='14px bold sans-serif';
    ctx.textAlign='center';
    ctx.fillText(towerTypes[selectedTowerType].cost + 'ü•¨', x, y+35);
  }

  // Spawn wave function
  function spawnWave() {
    const waveData = getWaveData(wave);
    let spawnDelay=0;
    for (let et of waveData.enemies) {
      setTimeout(() => {
        if (gameRunning) enemies.push(new Enemy(et));
      }, spawnDelay);
      spawnDelay += Math.max(600 - wave*20, 200);
    }
    updateWavePreview();
  }

  function getWaveData(waveNum) {
    const data={ enemies: [] };
    for (let i=0; i<Math.min(waveNum+3, 15); i++) data.enemies.push('basic');
    if (waveNum>=1) {
      for (let i=0; i<Math.floor(waveNum*1.5); i++) data.enemies.push('swarm');
    }
    if (waveNum>=2) {
      for (let i=0; i<Math.floor(waveNum/2); i++) data.enemies.push('fast');
    }
    if (waveNum>=3) {
      for (let i=0; i<Math.floor(waveNum/3); i++) data.enemies.push('flying');
    }
    if (waveNum>=4) {
      for (let i=0; i<Math.floor(waveNum/4); i++) data.enemies.push('tank');
    }
    if (waveNum>=5) {
      for (let i=0; i<Math.floor(waveNum/5); i++) data.enemies.push('worm');
    }
    if (waveNum>=6) {
      for (let i=0; i<Math.floor(waveNum/6); i++) data.enemies.push('spider');
    }
    if (waveNum>=7) {
      for (let i=0; i<Math.floor(waveNum/7); i++) data.enemies.push('shield');
    }
    if (waveNum%5===0) data.enemies.push('boss');
    if (waveNum%10===0) data.enemies.push('mega');
    return data;
  }

  function updateWavePreview() {
    const waveData = getWaveData(wave+1);
    const counts = {};
    waveData.enemies.forEach(t => counts[t]= (counts[t]||0)+1);
    let txt='';
    for (let [type,count] of Object.entries(counts)) {
      txt+=`${enemyTypes[type].emoji} ${enemyTypes[type].name} x${count}<br>`;
    }
    document.getElementById('wavePreview').innerHTML= txt || 'No enemies';
  }

  function updateUI() {
    document.getElementById('money').textContent= money;
    document.getElementById('health').textContent= health;
    document.getElementById('wave').textContent= wave;
    document.getElementById('score').textContent= score;
    document.getElementById('kills').textContent= kills;
    // update buttons
    Object.keys(towerTypes).forEach(t => {
      const btn=document.getElementById(t+'Tower');
      if (btn) btn.disabled= money< towerTypes[t].cost;
    });
  }

  // Mouse move
  document.querySelector('#gameCanvas').addEventListener('mousemove', e => {
    const rect = e.target.getBoundingClientRect();
    mouseX=e.clientX - rect.left;
    mouseY=e.clientY - rect.top;
  });

  // Main game loop
 async function gameLoop(timestamp) {
    if (!gameRunning || gamePaused) {
      requestAnimationFrame(gameLoop);
      return;
    }

    ctx.clearRect(0,0,canvas.width,canvas.height);
    // Draw background
    const gradient= ctx.createRadialGradient(400,250,0,400,250,500);
    gradient.addColorStop(0,'#98fb98');
    gradient.addColorStop(0.5,'#90ee90');
    gradient.addColorStop(1,'#7cfc00');
    ctx.fillStyle=gradient;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // Add grass texture
    ctx.fillStyle='#228b22aa';
    for (let i=0; i<50; i++) {
      const x= (i*37)%canvas.width;
      const y= (i*23)%canvas.height;
      ctx.fillRect(x,y,2,8);
      ctx.fillRect(x+5,y+3,2,6);
    }

    // Path
    drawPath();

    // Ghost tower
    if (selectedTowerType && !sellMode) {
      drawGhostTower(mouseX, mouseY);
    }

    // Draw towers
    for (let t of towers) {
      t.update(timestamp);
      t.draw();
    }

    // Enemies
    enemies = enemies.filter(e => {
      e.update(timestamp);
      e.draw();
      if (e.reachedEnd()) {
        health -= (e.type==='mega') ? 5 : (e.type==='boss') ? 3 : 1;
        updateUI();
        return false;
      }
      return e.health>0;
    });

    // Projectiles
    updateProjectiles(timestamp);
    drawProjectiles();

    // Particles
    updateParticles();
    drawParticles();

    // Effects
    updateEffects();
    drawEffects();

    // Check game over
    if (health<=0) {
      alert(`üéÆ GAME OVER! üéÆ\n\nüìä Final Statistics:\n‚Ä¢ Score: ${score.toLocaleString()}\n‚Ä¢ Waves Survived: ${wave-1}\n‚Ä¢ Kills: ${kills}\n‚Ä¢ Towers Built: ${towers.length}\n\nüèÜ ${getPerformanceRating()}\n\nThanks for defending the lettuce farm!`);
      location.reload();
      return;
    }

    // Next wave
    if (enemies.length===0 && gameRunning) {
      const bonus= 25 + wave*8;
      money+=bonus;
      wave++;
      gameRunning=false;
      effects.push({x:canvas.width/2, y:canvas.height/2, type:'waveComplete', life:120, maxLife:120});
      updateUI();
      updateWavePreview();
    }

    requestAnimationFrame(gameLoop);
  }

  function getPerformanceRating() {
    if (wave>=20) return "üèÜ LETTUCE LEGEND! Incredible defense!";
    if (wave>=15) return "ü•á SNAIL MASTER! Outstanding work!";
    if (wave>=10) return "ü•à GARDEN HERO! Great job!";
    if (wave>=5) return "ü•â PEST CONTROLLER! Good effort!";
    return "üå± ROOKIE FARMER! Keep practicing!";
  }

  // Event handlers
  document.getElementById('startWaveBtn').onclick= ()=> {
    if (!gameRunning) {
      gameRunning=true;
      spawnWave();
    }
  };
  document.getElementById('pauseBtn').onclick= ()=> {
    gamePaused= !gamePaused;
    document.getElementById('pauseBtn').textContent= gamePaused ? '‚ñ∂Ô∏è Resume':'‚è∏Ô∏è Pause';
  };
  document.getElementById('speedBtn').onclick= ()=> {
    gameSpeed= gameSpeed===1?2: gameSpeed===2?3:1;
    document.getElementById('speedBtn').textContent= `‚ö° Speed: ${gameSpeed}x`;
  };
  document.getElementById('sellBtn').onclick= ()=> {
    sellMode= !sellMode;
    document.getElementById('sellBtn').textContent= sellMode ? '‚ùå Exit Sell':'üí∞ Sell Mode';
    if (sellMode) {
      selectedTowerType=null;
      document.querySelectorAll('.tower-btn').forEach(b=>b.classList.remove('selected-tower'));
    }
  };

  // Tower buttons
  Object.keys(towerTypes).forEach(t => {
    document.getElementById(t+'Tower').onclick= ()=> {
      if (sellMode) {
        sellMode=false;
        document.getElementById('sellBtn').textContent='üí∞ Sell Mode';
      }
      document.querySelectorAll('.tower-btn').forEach(b=>b.classList.remove('selected-tower'));
      if (selectedTowerType===t) {
        selectedTowerType=null;
      } else {
        selectedTowerType=t;
        document.getElementById(t+'Tower').classList.add('selected-tower');
      }
    };
  });

  // Place tower
  document.querySelector('#gameCanvas').addEventListener('click', e => {
    const rect= e.target.getBoundingClientRect();
    const x= e.clientX - rect.left;
    const y= e.clientY - rect.top;
    if (sellMode) {
      // sell
      for (let i=towers.length-1; i>=0; i--) {
        const t= towers[i];
        if (Math.hypot(x-t.x, y-t.y)<25) {
          money+= t.getSellValue();
          towers.splice(i,1);
          updateUI();
          return;
        }
      }
      return;
    }
    if (!selectedTowerType) return;
    // Check valid position
    let valid= true;
    for (let p of path) {
      if (Math.hypot(x-p.x, y-p.y)<45) { valid=false; break; }
    }
    for (let t of towers) {
      if (Math.hypot(x-t.x, y-t.y)<40) { valid=false; break; }
    }
    if (valid && money>= towerTypes[selectedTowerType].cost) {
      towers.push(new Tower(x,y, selectedTowerType));
      money -= towerTypes[selectedTowerType].cost;
      updateUI();
    }
  });

  // Draw functions
  function drawPath() {
    ctx.strokeStyle='#654321';
    ctx.lineWidth=24;
    ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();

    ctx.strokeStyle='#8B7355';
    ctx.lineWidth=18;
    ctx.stroke();

    ctx.strokeStyle='#A0522D';
    ctx.lineWidth=2;
    ctx.setLineDash([10,5]);
    ctx.stroke();
    ctx.setLineDash([]);

    // farm
    const farmX=path[path.length-1].x;
    const farmY=path[path.length-1].y;
    ctx.fillStyle='#8B4513';
    ctx.fillRect(farmX-25, farmY-15,50,30);
    ctx.font='45px serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('ü•¨', farmX, farmY);
    ctx.fillStyle='#654321';
    ctx.fillRect(farmX-35, farmY-40,70,20);
    ctx.fillStyle='#fff';
    ctx.font='12px bold sans-serif';
    ctx.fillText('LETTUCE FARM', farmX, farmY-30);
  }

  function drawGhostTower(x,y) {
    if (!selectedTowerType || sellMode) return;
    let valid=false;
    for (let p of path) {
      if (Math.hypot(x-p.x, y-p.y)<45) { valid=false; break; }
    }
    for (let t of towers) {
      if (Math.hypot(x-t.x, y-t.y)<40) { valid=false; break; }
    }
    const canAfford= money >= towerTypes[selectedTowerType].cost;
    const alpha= (valid && canAfford) ? '88' : '44';
    const color= (valid && canAfford) ? towerTypes[selectedTowerType].color : '#ff0000';

    ctx.strokeStyle= color + '33';
    ctx.lineWidth=2;
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.arc(x, y, towerTypes[selectedTowerType].range, 0, Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw sprite as ghost
    const sprite = sprites[selectedTowerType];
    if (sprite) {
      const targetHeight=50;
      const scale= targetHeight / sprite.height;
      const width= sprite.width * scale;
      const height= sprite.height * scale;
      ctx.save();
      ctx.globalAlpha=0.4;
      ctx.translate(x, y);
      ctx.drawImage(sprite, -width/2, -height/2, width, height);
      ctx.globalAlpha=1;
      ctx.restore();
    }

    ctx.fillStyle= canAfford ? '#00ff00':'#ff0000';
    ctx.font='14px bold sans-serif';
    ctx.textAlign='center';
    ctx.fillText( towerTypes[selectedTowerType].cost + 'ü•¨', x, y+35);
  }

  function spawnWave() {
    const waveData= getWaveData(wave);
    let delay=0;
    for (let et of waveData.enemies) {
      setTimeout(()=> {
        if (gameRunning) enemies.push( new Enemy(et));
      }, delay);
      delay+= Math.max(600 - wave*20,200);
    }
    updateWavePreview();
  }

  function getWaveData(waveNum) {
    const data= {enemies:[]};
    for (let i=0; i<Math.min(waveNum+3,15); i++) data.enemies.push('basic');
    if (waveNum>=1) for (let i=0; i<Math.floor(waveNum*1.5); i++) data.enemies.push('swarm');
    if (waveNum>=2) for (let i=0; i<Math.floor(waveNum/2); i++) data.enemies.push('fast');
    if (waveNum>=3) for (let i=0; i<Math.floor(waveNum/3); i++) data.enemies.push('flying');
    if (waveNum>=4) for (let i=0; i<Math.floor(waveNum/4); i++) data.enemies.push('tank');
    if (waveNum>=5) for (let i=0; i<Math.floor(waveNum/5); i++) data.enemies.push('worm');
    if (waveNum>=6) for (let i=0; i<Math.floor(waveNum/6); i++) data.enemies.push('spider');
    if (waveNum>=7) for (let i=0; i<Math.floor(waveNum/7); i++) data.enemies.push('shield');
    if (waveNum%5===0) data.enemies.push('boss');
    if (waveNum%10===0) data.enemies.push('mega');
    return data;
  }

  function updateWavePreview() {
    const waveData= getWaveData(wave+1);
    const counts= {};
    waveData.enemies.forEach(t => counts[t]= (counts[t]||0)+1);
    let txt='';
    for (let [type,count] of Object.entries(counts)) {
      txt+= `${enemyTypes[type].emoji} ${enemyTypes[type].name} x${count}<br>`;
    }
    document.getElementById('wavePreview').innerHTML= txt || 'No enemies';
  }

  function updateUI() {
    document.getElementById('money').textContent= money;
    document.getElementById('health').textContent= health;
    document.getElementById('wave').textContent= wave;
    document.getElementById('score').textContent= score;
    document.getElementById('kills').textContent= kills;
    Object.keys(towerTypes).forEach(t => {
      const btn= document.getElementById(t+'Tower');
      if (btn) btn.disabled= money< towerTypes[t].cost;
    });
  }

  // Mouse move
  document.querySelector('#gameCanvas').addEventListener('mousemove', e => {
    const rect= e.target.getBoundingClientRect();
    mouseX= e.clientX - rect.left;
    mouseY= e.clientY - rect.top;
  });

  // Main game loop
  await loadSprites(); // Wait for all sprites to load

  // Start the game
  updateUI();
  updateWavePreview();
  requestAnimationFrame(gameLoop);

  // The key part: your `Tower.draw()` now uses sprites
  // You need to replace your existing Tower class definition with this one:
  class Tower {
    constructor(x,y,type) {
      this.x=x; this.y=y; this.type=type;
      this.lastShot=0;
      this.target=null;
      this.kills=0;
      this.totalDamage=0;
      this.level=1;
    }
    update(now) {
      const data= towerTypes[this.type];
      if (now - this.lastShot < 1000 / (data.speed * this.level * 0.1 + data.speed)) return;
      let target= this.findTarget();
      if (target) {
        this.shoot(target, now);
        this.lastShot=now;
      }
    }
    findTarget() {
      const data= towerTypes[this.type];
      let best=null; let bestVal= -1;
      enemies.forEach(e => {
        const dist= Math.hypot(e.x - this.x, e.y - this.y);
        if (dist<= data.range) {
          let val=0;
          switch(this.type) {
            case 'speed': val= 1000 - dist; break;
            case 'splash':
              const nearby= enemies.filter(en => Math.hypot(en.x - e.x, en.y - e.y)<=60).length;
              val= nearby*100 - dist; break;
            case 'slow': val= e.speed*100 - dist; break;
            default: val= e.health - dist; break;
          }
          if (val > bestVal) { best= e; bestVal= val; }
        }
      });
      return best;
    }
    shoot(target, now) {
      const data= towerTypes[this.type];
      const dmg= data.damage + (this.level-1)*5;
      projectiles.push({x:this.x, y:this.y, targetX: target.x, targetY: target.y, target: target, damage: dmg, speed:10, type:this.type, createdAt:now, tower:this});
      effects.push({x:this.x, y:this.y, type:'muzzleFlash', color: data.projectileColor, life:10, maxLife:10});
    }
    getSellValue() {
      return Math.floor(towerTypes[this.type].cost * 0.7 * this.level);
    }
    draw() {
      const data= towerTypes[this.type];

      // Show range circle
      if ((selectedTowerType===this.type && !sellMode)||sellMode) {
        ctx.strokeStyle= sellMode ? '#ff6666' : data.color + '44';
        ctx.lineWidth=2;
        ctx.setLineDash(sellMode ? [5,5] : []);
        ctx.beginPath();
        ctx.arc(this.x, this.y, data.range, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Background pattern
      this.drawBackground(data);

      // Draw the sprite scaled to 50px height
      const sprite= sprites[this.type];
      if (sprite) {
        const targetHeight= 50;
        const scale= targetHeight/ sprite.height;
        const width= sprite.width*scale;
        const height= sprite.height*scale;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.drawImage(sprite, -width/2, -height/2, width, height);
        ctx.restore();
      }

      ctx.strokeStyle= data.bgColor;
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 16, 0, Math.PI*2);
      ctx.stroke();

      if (this.level>1) {
        ctx.fillStyle= '#ffd700';
        ctx.font='10px bold sans-serif';
        ctx.textAlign='center';
        ctx.fillText('‚òÖ'.repeat(this.level-1), this.x, this.y+28);
      }

      if (sellMode) {
        ctx.fillStyle='#ffff00';
        ctx.font='12px bold sans-serif';
        ctx.textAlign='center';
        ctx.fillText('üí∞'+this.getSellValue(), this.x, this.y-35);
      }
    }
    drawBackground(data) {
      ctx.save();
      switch(this.type) {
        case 'basic':
          ctx.fillStyle='#8B7355';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y+5, 25, 12, 0, 0, Math.PI*2);
          ctx.fill();
          break;
        case 'speed':
          ctx.strokeStyle='#ff9999';
          ctx.lineWidth=3;
          for (let i=-2; i<=2; i++) {
            ctx.beginPath();
            ctx.moveTo(this.x -15 + i*8, this.y -15);
            ctx.lineTo(this.x +15 + i*8, this.y +15);
            ctx.stroke();
          }
          break;
        case 'splash':
          ctx.fillStyle='#66ff6644';
          ctx.beginPath(); ctx.arc(this.x, this.y,30,0,Math.PI*2); ctx.fill();
          ctx.fillStyle='#66ff6666';
          ctx.beginPath(); ctx.arc(this.x, this.y,25,0,Math.PI*2); ctx.fill();
          break;
        case 'slow':
          ctx.strokeStyle='#66ffff';
          ctx.lineWidth=2;
          for (let i=0; i<8; i++) {
            const angle= (i/8)*Math.PI*2;
            const x= this.x + Math.cos(angle)*15;
            const y= this.y + Math.sin(angle)*15;
            ctx.beginPath();
            ctx.moveTo(x,y);
            ctx.lineTo(this.x + Math.cos(angle)*25, this.y + Math.sin(angle)*25);
            ctx.stroke();
          }
          break;
        case 'laser':
          const g= ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 30);
          g.addColorStop(0,'#ffffff44');
          g.addColorStop(0.5,'#ff66ff22');
          g.addColorStop(1,'#6666ff11');
          ctx.fillStyle=g;
          ctx.beginPath();
          ctx.arc(this.x, this.y,30,0,Math.PI*2);
          ctx.fill();
          break;
        case 'poison':
          ctx.fillStyle='#99ff9933';
          for (let i=0; i<5; i++) {
            const angle= (i/5)*Math.PI*2;
            const x= this.x + Math.cos(angle)*20;
            const y= this.y + Math.sin(angle)*20;
            ctx.beginPath();
            ctx.arc(x,y,4+Math.sin(performance.now()*0.01 + i)*2,0,Math.PI*2);
            ctx.fill();
          }
          break;
      }
      ctx.restore();
    }
  }

  // Enemy class remains unchanged, but its draw() now uses sprites
  class Enemy {
    constructor(type, pathIndex=0) {
      this.type= type;
      this.maxHealth= enemyTypes[type].health*(1+wave*0.1);
      this.health= this.maxHealth;
      this.speed= enemyTypes[type].speed;
      this.reward= enemyTypes[type].reward;
      this.pathIndex= pathIndex;
      this.x= path[0].x;
      this.y= path[0].y;
      this.slowEffect=1;
      this.slowUntil=0;
      this.poisonDamage=0;
      this.poisonUntil=0;
      this.shields= this.type==='shield' ? 2 : 0;
    }
    update(now) {
      if (now > this.slowUntil) this.slowEffect=1;
      if (now< this.poisonUntil && now % 500<16) {
        this.takeDamage(this.poisonDamage, 'poison');
      }
      const currentSpeed= this.speed* this.slowEffect* gameSpeed;
      if (this.pathIndex< path.length-1) {
        const current= path[this.pathIndex];
        const next= path[this.pathIndex+1];
        const dx= next.x - current.x;
        const dy= next.y - current.y;
        const dist= Math.hypot(dx,dy);
        if (dist>0) {
          const moveX= (dx/dist)* currentSpeed;
          const moveY= (dy/dist)* currentSpeed;
          this.x+= moveX;
          this.y+= moveY;
          if (Math.hypot(next.x - this.x, next.y - this.y)< currentSpeed) {
            this.pathIndex++;
            if (this.pathIndex< path.length) {
              this.x= path[this.pathIndex].x;
              this.y= path[this.pathIndex].y;
            }
          }
        }
      }
    }
    takeDamage(damage, effectType='basic') {
      let actualDamage= damage;
      if (this.shields>0 && effectType!=='poison') {
        this.shields--;
        actualDamage*=0.5;
        effects.push({x:this.x,y:this.y,type:'shieldBreak',life:30, maxLife:30});
      }
      this.health-=actualDamage;
      if (effectType==='slow') {
        this.slowEffect=0.4;
        this.slowUntil= performance.now()+3000;
      } else if (effectType==='poison') {
        this.poisonDamage= Math.max(this.poisonDamage, damage*0.5);
        this.poisonUntil= performance.now()+4000;
      }
      particles.push({x:this.x+(Math.random()-0.5)*20,y:this.y-25,text:'-'+Math.floor(actualDamage),life:60, color: (effectType==='poison') ? '#99ff99' : '#ffff00', vx:(Math.random()-0.5)*2, vy:-2});
      return this.health<=0;
    }
    reachedEnd() {
      return this.pathIndex>= path.length-1 && this.x>= path[this.path.length-1].x;
    }
    draw() {
      // effects
      if (this.slowEffect<1) {
        ctx.fillStyle= '#00ffff33';
        ctx.beginPath(); ctx.arc(this.x, this.y, 20, 0, Math.PI*2); ctx.fill();
      }
      if (this.poisonDamage>0) {
        ctx.fillStyle= '#99ff9933';
        ctx.beginPath(); ctx.arc(this.x, this.y, 18, 0, Math.PI*2); ctx.fill();
      }
      if (this.shields>0) {
        ctx.strokeStyle='#4444ff';
        ctx.lineWidth=3;
        ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.arc(this.x, this.y, 22, 0, Math.PI*2); ctx.stroke();
        ctx.setLineDash([]);
      }

      const sprite= sprites[this.type];
      const size= (this.type==='mega') ?36 : (this.type==='boss') ?32:28;
      if (sprite) {
        const targetHeight= size;
        const scale= targetHeight/ sprite.height;
        const width= sprite.width*scale;
        const height= sprite.height*scale;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.drawImage(sprite, -width/2, -height/2, width, height);
        ctx.restore();
      } else {
        ctx.font= size + 'px serif';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(enemyTypes[this.type].emoji, this.x, this.y);
      }

      // health bar
      const barW=35; const barH=5;
      const hpPercent= this.health/ this.maxHealth;
      ctx.fillStyle='#000';
      ctx.fillRect(this.x - barW/2 -1, this.y -30 -1, barW+2, barH+2);
      ctx.fillStyle='#f00';
      ctx.fillRect(this.x - barW/2, this.y -30, barW, barH);
      ctx.fillStyle= hpPercent>0.6 ? '#0f0' : hpPercent>0.3 ? '#ff0' : '#f44';
      ctx.fillRect(this.x - barW/2, this.y -30, barW*hpPercent, barH);

      if (this.shields>0) {
        ctx.fillStyle='#4444ff';
        ctx.font='12px sans-serif';
        ctx.fillText('üõ°Ô∏è'.repeat(this.shields), this.x, this.y -40);
      }
    }
  }

  // updateProjectiles, handleProjectileHit, distanceToLine, etc. same as before
  // ... (rest of your code, same as previous, unchanged) ...

  // Initialize game after sprites are loaded
  await loadSprites();
  updateUI();
  updateWavePreview();
  requestAnimationFrame(gameLoop);
})();
</script>

</body>
</html>
