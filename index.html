<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flumgus Tower Defense</title>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden;
    height: 100vh;
  }
  /* Scroll container to allow scrolling of entire game area */
  #scrollContainer {
    width: 100%;
    height: 100vh;
    overflow-y: auto;
    box-sizing: border-box;
  }
  /* Keep styling for the game and sidebar inside scroll container */
  #gameContainer {
    display: flex;
    min-width: 1200px; /* Ensures horizontal scroll if needed */
  }
  #gameCanvas {
    background: linear-gradient(135deg, #98fb98 0%, #90ee90 50%, #7cfc00 100%);
    display: block;
    border: 4px solid #2f4f2f;
    cursor: crosshair;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
    margin-left: 20px;
  }
  #sidebar {
    width: 220px;
    background: linear-gradient(180deg, #2d2d2d 0%, #1a1a1a 100%);
    color: white;
    padding: 20px;
    overflow-y: auto;
    border-left: 3px solid #444;
    box-shadow: -5px 0 15px rgba(0,0,0,0.3);
    flex-shrink: 0;
  }
  /* Keep existing styles for UI and buttons */
  #ui {
    background: linear-gradient(90deg, #333 0%, #2a2a2a 100%);
    color: white;
    padding: 15px;
    text-align: center;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 3px solid #444;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  }
  .tower-btn {
    display: block;
    width: 100%;
    margin: 10px 0;
    padding: 12px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 11px;
    cursor: pointer;
    border: 2px solid #555;
    background: linear-gradient(135deg, #444 0%, #333 100%);
    color: white;
    border-radius: 8px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }
  .tower-btn:hover {
    background: linear-gradient(135deg, #555 0%, #444 100%);
    border-color: #777;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }
  .tower-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
  }
  #gameInfo {
    text-align: left;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  }
  #waveInfo {
    margin: 20px 0;
    padding: 15px;
    background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%);
    border-radius: 8px;
    border: 1px solid #333;
  }
  button {
    font-family: 'Segoe UI', sans-serif;
    padding: 10px 18px;
    font-size: 14px;
    cursor: pointer;
    margin: 0 5px;
    border: 2px solid #555;
    background: linear-gradient(135deg, #4a4a4a 0%, #3a3a3a 100%);
    color: white;
    border-radius: 6px;
    transition: all 0.2s ease;
  }
  button:hover {
    background: linear-gradient(135deg, #5a5a5a 0%, #4a4a4a 100%);
    transform: translateY(-1px);
  }
  .selected-tower {
    background: linear-gradient(135deg, #666 0%, #555 100%) !important;
    border-color: #aaa !important;
    transform: translateY(-2px);
    box-shadow: 0 0 15px rgba(170, 170, 170, 0.5);
  }
  .tower-stats {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
    font-size: 9px;
    opacity: 0.8;
  }
  #particles {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 1000;
  }
</style>
</head>
<body>

<!-- Wrap everything in the scroll container for scrolling -->
<div id="scrollContainer">
  <!-- Existing UI at top -->
  <div id="ui">
    <div id="gameInfo">
      <div>💚 Health: <span id="health">25</span>  |  🥬 Lettuce Currency: <span id="money">120</span></div>
      <div>Wave: <span id="wave">1</span>  |  Score: <span id="score">0</span>  |  Kills: <span id="kills">0</span></div>
    </div>
    <div>
      <button id="startWaveBtn">Start Wave</button>
      <button id="pauseBtn">Pause</button>
      <button id="speedBtn">Speed: 1x</button>
      <button id="sellBtn">Sell Mode</button>
    </div>
  </div>

  <!-- Main game container with canvas and sidebar -->
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div id="sidebar">
      <h3>🐌 Elite Snail Defense Corps</h3>
      
      <button class="tower-btn" id="basicTower">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div>
            <strong>Normal Snail 🐌</strong><br>
            <small>Steady and reliable defender</small>
          </div>
          <div style="text-align: right;">
            <div>💰 25 🥬</div>
          </div>
        </div>
        <div class="tower-stats">
          <span>⚔️ 30 DMG</span>
          <span>🎯 85 Range</span>
          <span>⚡ 1.0 Speed</span>
        </div>
      </button>

      <button class="tower-btn" id="speedTower">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div>
            <strong>Turbo Snail 🏎️</strong><br>
            <small>Lightning-fast rapid fire</small>
          </div>
          <div style="text-align: right;">
            <div>💰 50 🥬</div>
          </div>
        </div>
        <div class="tower-stats">
          <span>⚔️ 15 DMG</span>
          <span>🎯 75 Range</span>
          <span>⚡ 2 Speed</span>
        </div>
      </button>

      <button class="tower-btn" id="splashTower">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div>
            <strong>Slime Bomber 🟢</strong><br>
            <small>Explosive area damage</small>
          </div>
          <div style="text-align: right;">
            <div>💰 70 🥬</div>
          </div>
        </div>
        <div class="tower-stats">
          <span>⚔️ 50 DMG</span>
          <span>🎯 95 Range</span>
          <span>⚡ 0.8 Speed</span>
        </div>
      </button>

      <button class="tower-btn" id="slowTower">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div>
            <strong>Frost Shell 🧊</strong><br>
            <small>Freezing crowd control</small>
          </div>
          <div style="text-align: right;">
            <div>💰 55 🥬</div>
          </div>
        </div>
        <div class="tower-stats">
          <span>⚔️ 25 DMG</span>
          <span>🎯 90 Range</span>
          <span>⚡ 1.3 Speed</span>
        </div>
      </button>

      <button class="tower-btn" id="laserTower">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div>
            <strong>Prism Snail 🌈</strong><br>
            <small>Piercing laser beam</small>
          </div>
          <div style="text-align: right;">
            <div>💰 15000 🥬</div>
          </div>
        </div>
        <div class="tower-stats">
          <span>⚔️ 450 DMG</span>
          <span>🎯 300 Range</span>
          <span>⚡ 5 Speed</span>
        </div>
      </button>

      <button class="tower-btn" id="poisonTower">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div>
            <strong>Toxic Spiral 💚</strong><br>
            <small>Damage over time</small>
          </div>
          <div style="text-align: right;">
            <div>💰 65 🥬</div>
          </div>
        </div>
        <div class="tower-stats">
          <span>⚔️ 15+20 DMG</span>
          <span>🎯 80 Range</span>
          <span>⚡ 1.2 Speed</span>
        </div>
      </button>

      <button class="tower-btn" id="support">
  <div style="display: flex; align-items: center; justify-content: space-between;">
    <div>
      <strong>Money Snail 💰</strong><br>
      <small>Generates income</small>
    </div>
    <div style="text-align: right;">
      <div>💰 40 🥬</div>
    </div>
  </div>
  <div class="tower-stats">
    <span>💸 +10 🥬 / 3 sec</span>
  </div>
</button>
      
      <div id="waveInfo">
        <h4>📊 Next Wave Preview:</h4>
        <div id="wavePreview">Click Start Wave!</div>
      </div>
      
      <div style="margin-top: 20px; font-size: 11px; color: #bbb; line-height: 1.4;">
        <p>🎯 <strong>Strategy Tips:</strong></p>
        <p>• Mix different snail types for optimal defense</p>
        <p>• Use Frost Shells to slow down fast enemies</p>
        <p>• Slime Bombers excel against groups</p>
        <p>• Prism Snails can hit multiple targets</p>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  
  // Game state
  let gameRunning = false;
  let gamePaused = false;
  let gameSpeed = 1;
  let money = 120;
  let health = 25;
  let wave = 1;
  let score = 0;
  let kills = 0;
  let selectedTowerType = null;
  let sellMode = false;
  
  // Arrays
  let towers = [];
  let enemies = [];
  let projectiles = [];
  let particles = [];
  let effects = [];
  
  // Mouse tracking
  let mouseX = 0;
  let mouseY = 0;
  
  // Enhanced path (more winding)
const path = [
{x: 338, y: -49},
  {x: 340, y: 25}, 
  {x: 439, y: 64}, 
  {x: 324, y: 140},
  {x: 240, y: 68},
  {x: 282, y: -15},
  {x: -1, y: -96}, 
  {x: -124, y: 50},
  {x: -117, y: 473},
  {x: 59, y: 637},
  {x: 810, y: 601},
  {x: 880, y: 138},
  {x: 763, y: 66},
  {x: 681, y: 137}, 
  {x: 565, y: 181},
  {x: 563, y: 65}, 
  {x: 689, y: 24}, 
  {x: 716, y: 183},
  {x: 842, y: 223},
  {x: 957, y: 575},
  {x: 175, y: 574},
  {x: -53, y: 525},
  {x: -75, y: 235},
  {x: 42, y: 265}, 
  {x: 41, y: 344}, 
  {x: 120, y: 423},
  {x: 202, y: 343},
  {x: 160, y: 269},
  {x: 237, y: 297},
  {x: 281, y: 384},
  {x: 200, y: 462},
  {x: 151, y: 528},
  {x: 758, y: 694},
  {x: 945, y: 177},
  {x: 856, y: -23},
  {x: 530, y: -78},
  {x: 486, y: 72}, 
  {x: 437, y: 143},
  {x: 274, y: 153},
  {x: 343, y: 201},
  {x: 233, y: 219},
  {x: 388, y: 256}, 
  {x: 455, y: 210}, 
  {x: 492, y: 256},
  {x: 572, y: 386},
  {x: 707, y: 342},
  {x: 821, y: 342},
  {x: 887, y: 667},
  {x: 428, y: 529},
  {x: 453, y: 387},
  {x: 306, y: 365},
  {x: 424, y: 335}, 
  {x: 325, y: 299}, 
  {x: 432, y: 282},
  {x: 467, y: 281},
  {x: 502, y: 350},
  {x: 596, y: 302},
  {x: 666, y: 248},
  {x: 512, y: 180}
]
  
  // Enhanced tower types with unique backgrounds
  const towerTypes = {
    basic: { 
      cost: 25, damage: 30, range: 85, speed: 1.0, emoji: '🐌', 
      color: '#8B4513', bgColor: '#654321', name: 'Normal Snail',
      projectileColor: '#8B4513', effect: 'basic'
    },
    speed: { 
      cost: 50, damage: 15, range: 75, speed: 20, emoji: '🐌', 
      color: '#ff4444', bgColor: '#cc3333', name: 'Turbo Snail',
      projectileColor: '#ff6666', effect: 'basic'
    },
    splash: { 
      cost: 70, damage: 50, range: 95, speed: 0.8, emoji: '🐌', 
      color: '#00ff00', bgColor: '#00cc00', name: 'Slime Bomber',
      projectileColor: '#66ff66', effect: 'splash'
    },
    slow: { 
      cost: 55, damage: 25, range: 90, speed: 1.3, emoji: '🐌', 
      color: '#00ffff', bgColor: '#00cccc', name: 'Frost Shell',
      projectileColor: '#66ffff', effect: 'slow'
    },
    laser: {
      cost: 15000, damage: 450, range: 300, speed: 5, emoji: '🐌',
      color: '#ff00ff', bgColor: '#cc00cc', name: 'Prism Snail',
      projectileColor: '#ff66ff', effect: 'pierce'
    },
    poison: {
      cost: 65, damage: 15, range: 80, speed: 1.2, emoji: '🐌',
      color: '#99ff99', bgColor: '#66cc66', name: 'Toxic Spiral',
      projectileColor: '#99ff99', effect: 'poison'
    },
    support: { 
  cost: 100, damage: 0, range: 0, speed: 0, emoji: '🐌', 
  color: '#ffff00', bgColor: '#ffff66', name: 'Money Snail', 
  effect: 'support', 
  produceInterval: 3000, // every 3 seconds
  produceAmount: 25 // amount of money generated
}
  };
  
  // Enhanced enemy types
  const enemyTypes = {
    basic: { health: 65, speed: 1, reward: 10, emoji: '🐛', name: 'Garden Bug' },
    fast: { health: 39, speed: 2.2, reward: 12, emoji: '🐜', name: 'Speed Ant' },
    tank: { health: 350, speed: 0.6, reward: 20, emoji: '🪲', name: 'Armored Beetle' },
    boss: { health: 420, speed: 0.8, reward: 30, emoji: '🦂', name: 'Scorpion Boss' },
    flying: { health: 85, speed: 1.8, reward: 12, emoji: '🦟', name: 'Buzz Mosquito' },
    worm: { health: 150, speed: 0.9, reward: 15, emoji: '🪱', name: 'Earth Worm' },
    spider: { health: 100, speed: 1.4, reward: 15, emoji: '🕷️', name: 'Web Spider' },
    mega: { health: 5000, speed: 0.5, reward: 200, emoji: '🐉', name: 'Mega Dragon' },
    swarm: { health: 25, speed: 2.5, reward: 2, emoji: '🦗', name: 'Swarm Locust' },
    shield: { health: 120, speed: 1.1, reward: 20, emoji: '🛡️', name: 'Shield Bug' }
  };
  
  class Tower {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.type = type;
      this.lastShot = 0;
      this.target = null;
      this.kills = 0;
      this.totalDamage = 0;
      this.level = 1;
    }
    
    update(now) {
      const towerData = towerTypes[this.type];
      if (now - this.lastShot < 1000 / (towerData.speed * this.level * 0.1 + towerData.speed)) return;
      
      // Find target based on tower type strategy
      let target = this.findTarget();
      
      if (target) {
        this.shoot(target, now);
        this.lastShot = now;
      }
    }
    
    findTarget() {
      const towerData = towerTypes[this.type];
      let bestTarget = null;
      let bestValue = -1;
      
      enemies.forEach(enemy => {
        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
        if (dist <= towerData.range) {
          let value = 0;
          
          // Different targeting strategies
          switch(this.type) {
            case 'speed':
              value = 1000 - dist; // Closest first
              break;
            case 'splash':
              // Count nearby enemies for splash potential
              let nearbyCount = enemies.filter(e => 
                Math.hypot(e.x - enemy.x, e.y - enemy.y) <= 60
              ).length;
              value = nearbyCount * 100 - dist;
              break;
            case 'slow':
              value = enemy.speed * 100 - dist; // Fast enemies first
              break;
            default:
              value = enemy.health - dist; // Strongest first
          }
          
          if (value > bestValue) {
            bestValue = value;
            bestTarget = enemy;
          }
        }
      });
      
      return bestTarget;
    }
    
    shoot(target, now) {
      const towerData = towerTypes[this.type];
      const damage = towerData.damage + (this.level - 1) * 5;
      
      projectiles.push({
        x: this.x,
        y: this.y,
        targetX: target.x,
        targetY: target.y,
        target: target,
        damage: damage,
        speed: 10,
        type: this.type,
        createdAt: now,
        tower: this
      });
      
      // Add muzzle flash effect
      effects.push({
        x: this.x,
        y: this.y,
        type: 'muzzleFlash',
        color: towerData.projectileColor,
        life: 10,
        maxLife: 10
      });
    }
    
    getSellValue() {
      return Math.floor(towerTypes[this.type].cost * 0.7 * this.level);
    }
    
    draw() {
      const towerData = towerTypes[this.type];
      
      // Draw range circle when selected or in sell mode
      if ((selectedTowerType === this.type && !sellMode) || sellMode) {
        ctx.strokeStyle = sellMode ? '#ff6666' : towerData.color + '44';
        ctx.lineWidth = 2;
        ctx.setLineDash(sellMode ? [5, 5] : []);
        ctx.beginPath();
        ctx.arc(this.x, this.y, towerData.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw unique background for each tower type
      this.drawBackground(towerData);
      
      // Draw tower base with gradient
      const gradient = ctx.createRadialGradient(this.x, this.y, 8, this.x, this.y, 22);
      gradient.addColorStop(0, towerData.color);
      gradient.addColorStop(1, towerData.bgColor);
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
      ctx.fill();
      
      // Border
      ctx.strokeStyle = towerData.bgColor;
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Inner highlight
      ctx.strokeStyle = towerData.color + '88';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 16, 0, Math.PI * 2);
      ctx.stroke();
      
      // Draw snail emoji
      ctx.font = (26 + this.level * 2) + 'px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(towerData.emoji, this.x, this.y - 2);
      
      // Draw level indicator
      if (this.level > 1) {
        ctx.fillStyle = '#ffd700';
        ctx.font = '10px bold sans-serif';
        ctx.fillText('★'.repeat(this.level - 1), this.x, this.y + 28);
      }
      
      // Draw sell value when in sell mode
      if (sellMode) {
        ctx.fillStyle = '#ffff00';
        ctx.font = '12px bold sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('💰' + this.getSellValue(), this.x, this.y - 35);
      }
    }
    
    drawBackground(towerData) {
      // Draw unique background patterns for each tower type
      ctx.save();
      
      switch(this.type) {
        case 'basic':
          // Simple dirt mound
          ctx.fillStyle = '#8B7355';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y + 5, 25, 12, 0, 0, Math.PI * 2);
          ctx.fill();
          break;
          
        case 'speed':
          // Racing stripes
          ctx.strokeStyle = '#ff9999';
          ctx.lineWidth = 3;
          for(let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.moveTo(this.x - 15 + i * 8, this.y - 15);
            ctx.lineTo(this.x + 15 + i * 8, this.y + 15);
            ctx.stroke();
          }
          break;
          
        case 'splash':
          // Slime puddle
          ctx.fillStyle = '#66ff6644';
          ctx.beginPath();
          ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#66ff6666';
          ctx.beginPath();
          ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
          ctx.fill();
          break;
          
        case 'slow':
          // Ice crystals
          ctx.strokeStyle = '#66ffff';
          ctx.lineWidth = 2;
          for(let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const x1 = this.x + Math.cos(angle) * 15;
            const y1 = this.y + Math.sin(angle) * 15;
            const x2 = this.x + Math.cos(angle) * 25;
            const y2 = this.y + Math.sin(angle) * 25;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }
          break;
          
        case 'laser':
          // Prism effect
          const prismGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 30);
          prismGradient.addColorStop(0, '#ffffff44');
          prismGradient.addColorStop(0.5, '#ff66ff22');
          prismGradient.addColorStop(1, '#6666ff11');
          ctx.fillStyle = prismGradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
          ctx.fill();
          break;
          
        case 'poison':
          // Toxic bubbles
          ctx.fillStyle = '#99ff9933';
          for(let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const x = this.x + Math.cos(angle) * 20;
            const y = this.y + Math.sin(angle) * 20;
            ctx.beginPath();
            ctx.arc(x, y, 4 + Math.sin(performance.now() * 0.01 + i) * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
      }
      
      ctx.restore();
    }
  }
  
  class Enemy {
    constructor(type, pathIndex = 0) {
      this.type = type;
      this.maxHealth = enemyTypes[type].health * (1 + wave * 0.1);
      this.health = this.maxHealth;
      this.speed = enemyTypes[type].speed;
      this.reward = enemyTypes[type].reward;
      this.pathIndex = pathIndex;
      this.x = path[0].x;
      this.y = path[0].y;
      this.slowEffect = 1;
      this.slowUntil = 0;
      this.poisonDamage = 0;
      this.poisonUntil = 0;
      this.shields = this.type === 'shield' ? 2 : 0;
    }
    
    update(now) {
      // Handle status effects
      if (now > this.slowUntil) {
        this.slowEffect = 1;
      }
      
      // Handle poison damage
      if (now < this.poisonUntil && now % 500 < 16) {
        this.takeDamage(this.poisonDamage, 'poison');
      }
      
      const currentSpeed = this.speed * this.slowEffect * gameSpeed;
      
      if (this.pathIndex < path.length - 1) {
        const current = path[this.pathIndex];
        const next = path[this.pathIndex + 1];
        
        const dx = next.x - current.x;
        const dy = next.y - current.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance > 0) {
          const moveX = (dx / distance) * currentSpeed;
          const moveY = (dy / distance) * currentSpeed;
          
          this.x += moveX;
          this.y += moveY;
          
          // Check if reached next waypoint
          const distToNext = Math.hypot(next.x - this.x, next.y - this.y);
          if (distToNext < currentSpeed) {
            this.pathIndex++;
            if (this.pathIndex < path.length) {
              this.x = path[this.pathIndex].x;
              this.y = path[this.pathIndex].y;
            }
          }
        }
      }
    }
    
    takeDamage(damage, effectType = 'basic') {
      let actualDamage = damage;
      
      // Handle shields
      if (this.shields > 0 && effectType !== 'poison') {
        this.shields--;
        actualDamage *= 0.5;
        
        // Shield break effect
        effects.push({
          x: this.x,
          y: this.y,
          type: 'shieldBreak',
          life: 30,
          maxLife: 30
        });
      }
      
      this.health -= actualDamage;
      
      // Apply special effects
      if (effectType === 'slow') {
        this.slowEffect = 0.4;
        this.slowUntil = performance.now() + 3000;
      } else if (effectType === 'poison') {
        this.poisonDamage = Math.max(this.poisonDamage, damage * 0.5);
        this.poisonUntil = performance.now() + 4000;
      }
      
      // Create damage particle
      const color = {
        basic: '#ffff00',
        slow: '#00ffff',
        splash: '#00ff00',
        poison: '#99ff99',
        pierce: '#ff00ff'
      }[effectType] || '#ffff00';
      
      particles.push({
        x: this.x + (Math.random() - 0.5) * 20,
        y: this.y - 25,
        text: '-' + Math.floor(actualDamage),
        life: 60,
        color: color,
        vx: (Math.random() - 0.5) * 2,
        vy: -2
      });
      
      return this.health <= 0;
    }
    
    reachedEnd() {
      return this.pathIndex >= path.length - 1 && this.x >= path[path.length - 1].x;
    }
    
    draw() {
      const enemyData = enemyTypes[this.type];
      
      // Draw status effect auras
      if (this.slowEffect < 1) {
        ctx.fillStyle = '#00ffff33';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
        ctx.fill();
      }
      
      if (this.poisonDamage > 0) {
        ctx.fillStyle = '#99ff9933';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 18, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw shields
      if (this.shields > 0) {
        ctx.strokeStyle = '#4444ff';
        ctx.lineWidth = 3;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 22, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw enemy with size variation
      const size = this.type === 'mega' ? 36 : this.type === 'boss' ? 32 : 28;
      ctx.font = size + 'px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(enemyData.emoji, this.x, this.y);
      
      // Draw health bar
      const barWidth = 35;
      const barHeight = 5;
      const healthPercent = this.health / this.maxHealth;
      
      // Background
      ctx.fillStyle = '#000';
      ctx.fillRect(this.x - barWidth/2 - 1, this.y - 30 - 1, barWidth + 2, barHeight + 2);
      
      // Health bar
      ctx.fillStyle = '#f00';
      ctx.fillRect(this.x - barWidth/2, this.y - 30, barWidth, barHeight);
      ctx.fillStyle = healthPercent > 0.6 ? '#0f0' : healthPercent > 0.3 ? '#ff0' : '#f44';
      ctx.fillRect(this.x - barWidth/2, this.y - 30, barWidth * healthPercent, barHeight);
      
      // Shield indicators
      if (this.shields > 0) {
        ctx.fillStyle = '#4444ff';
        ctx.font = '12px sans-serif';
        ctx.fillText('🛡️'.repeat(this.shields), this.x, this.y - 40);
      }
    }
  }
  
  function updateProjectiles(now) {
    projectiles = projectiles.filter(proj => {
      const dx = proj.targetX - proj.x;
      const dy = proj.targetY - proj.y;
      const distance = Math.hypot(dx, dy);
      
      if (distance < proj.speed || now - proj.createdAt > 3000) {
        // Hit target or timeout
        if (proj.target && enemies.includes(proj.target)) {
          handleProjectileHit(proj);
        }
        return false;
      }
      
      // Move projectile
      proj.x += (dx / distance) * proj.speed;
      proj.y += (dy / distance) * proj.speed;
      
      // Update target position for homing
      if (proj.target && enemies.includes(proj.target)) {
        proj.targetX = proj.target.x;
        proj.targetY = proj.target.y;
      }
      
      return true;
    });
  }
  
  function handleProjectileHit(proj) {
    const killed = proj.target.takeDamage(proj.damage, proj.type);
    
    // Special effects based on projectile type
    switch(proj.type) {
      case 'splash':
        // Splash damage
        enemies.forEach(enemy => {
          if (enemy !== proj.target) {
            const dist = Math.hypot(enemy.x - proj.target.x, enemy.y - proj.target.y);
            if (dist <= 60) {
              enemy.takeDamage(proj.damage * 0.6, 'splash');
            }
          }
        });
        // Splash visual effect
        effects.push({
          x: proj.target.x,
          y: proj.target.y,
          type: 'explosion',
          color: '#00ff00',
          life: 30,
          maxLife: 30
        });
        break;
      case 'laser':
        // Pierce through enemies
        const pierceTargets = enemies.filter(enemy => {
          if (enemy === proj.target) return false;
          const dist = distanceToLine(enemy.x, enemy.y, proj.x, proj.target.x, proj.y, proj.target.y);
          return dist < 15;
        });
        pierceTargets.forEach(enemy => {
          enemy.takeDamage(proj.damage * 0.8, 'pierce');
        });
        break;
      case 'poison':
        // Apply poison effect
        proj.target.poisonDamage = Math.max(proj.target.poisonDamage, proj.damage * 0.3);
        proj.target.poisonUntil = performance.now() + 5000;
        break;
    }
    if (killed) {
      score += proj.target.reward;
      money += proj.target.reward;
      kills++;
      proj.tower.kills++;
      proj.tower.totalDamage += proj.damage;
      
      // Upgrade tower after certain kills
      if (proj.tower.kills >= 10 * proj.tower.level && proj.tower.level < 3) {
        proj.tower.level++;
        effects.push({
          x: proj.tower.x,
          y: proj.tower.y,
          type: 'levelUp',
          life: 60,
          maxLife: 60
        });
      }
      updateUI();
    }
  }
  
  function distanceToLine(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    if (lenSq !== 0) param = dot / lenSq;
    let xx, yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  function drawProjectiles() {
    projectiles.forEach(proj => {
      const towerData = towerTypes[proj.type];
      if (proj.type === 'laser') {
        ctx.strokeStyle = towerData.projectileColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(proj.x, proj.y);
        ctx.lineTo(proj.targetX, proj.targetY);
        ctx.stroke();
        ctx.strokeStyle = towerData.projectileColor + '44';
        ctx.lineWidth = 6;
        ctx.stroke();
      } else {
        ctx.fillStyle = towerData.projectileColor;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.type === 'splash' ? 5 : 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = towerData.projectileColor + '66';
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.type === 'splash' ? 8 : 6, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  
  function updateParticles() {
    particles = particles.filter(p => {
      p.x += p.vx || 0;
      p.y += p.vy || -1;
      p.life--;
      return p.life > 0;
    });
  }
  
  function drawParticles() {
    particles.forEach(p => {
      const alpha = p.life / 60;
      ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
      ctx.font = '14px bold sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.text, p.x, p.y);
    });
  }
  
  function updateEffects() {
    effects = effects.filter(e => {
      e.life--;
      return e.life > 0;
    });
  }
  
  function drawEffects() {
    effects.forEach(e => {
      const alpha = e.life / e.maxLife;
      switch(e.type) {
        case 'explosion':
          const radius = (1 - alpha) * 50;
          ctx.fillStyle = e.color + Math.floor(alpha * 100).toString(16).padStart(2, '0');
          ctx.beginPath();
          ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'muzzleFlash':
          ctx.fillStyle = e.color + Math.floor(alpha * 200).toString(16).padStart(2, '0');
          ctx.beginPath();
          ctx.arc(e.x, e.y, alpha * 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'levelUp':
          ctx.fillStyle = '#ffd700' + Math.floor(alpha * 255).toString(16).padStart(2, '0');
          ctx.font = (20 + (1 - alpha) * 10) + 'px bold sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('LEVEL UP!', e.x, e.y - 40);
          break;
        case 'shieldBreak':
          const shieldRadius = alpha * 25;
          ctx.strokeStyle = '#4444ff' + Math.floor(alpha * 255).toString(16).padStart(2, '0');
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(e.x, e.y, shieldRadius, 0, Math.PI * 2);
          ctx.stroke();
          break;
      }
    });
  }
  
  function drawPath() {
    // Enhanced path with multiple layers
    ctx.strokeStyle = '#654321';
    ctx.lineWidth = 24;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
      ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
    
    // Inner path
    ctx.strokeStyle = '#8B7355';
    ctx.lineWidth = 18;
    ctx.stroke();
    
    // Path centerline
    ctx.strokeStyle = '#A0522D';
    ctx.lineWidth = 2;
    ctx.setLineDash([10, 5]);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Enhanced lettuce farm at end
    const farmX = path[path.length - 1].x;
    const farmY = path[path.length - 1].y;
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(farmX - 25, farmY - 15, 50, 30);
    ctx.font = '45px serif';
    ctx.textAlign = 'center';
    ctx.fillText('🥬', farmX, farmY);
    ctx.fillStyle = '#654321';
    ctx.fillRect(farmX - 35, farmY - 40, 70, 20);
    ctx.fillStyle = '#fff';
    ctx.font = '12px bold sans-serif';
    ctx.fillText('LETTUCE FARM', farmX, farmY - 30);
  }
  
  function drawGhostTower(x, y) {
    if (!selectedTowerType || sellMode) return;
    
    const towerData = towerTypes[selectedTowerType];
    let validPosition = true;
    for (let pathPoint of path) {
      if (Math.hypot(x - pathPoint.x, y - pathPoint.y) < 45) {
        validPosition = false;
        break;
      }
    }
    for (let tower of towers) {
      if (Math.hypot(x - tower.x, y - tower.y) < 40) {
        validPosition = false;
        break;
      }
    }
    const canAfford = money >= towerData.cost;
    const alpha = validPosition && canAfford ? '88' : '44';
    const color = validPosition && canAfford ? towerData.color : '#ff0000';

    ctx.strokeStyle = color + '33';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(x, y, towerData.range, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = color + '22';
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = color + alpha;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = color + alpha;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.font = '28px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = color + alpha;
    ctx.fillText(towerData.emoji, x, y - 2);

    ctx.fillStyle = canAfford ? '#00ff00' : '#ff0000';
    ctx.font = '14px bold sans-serif';
    ctx.fillText(towerData.cost + '🥬', x, y + 35);
  }
  
  function spawnWave() {
    const waveData = getWaveData(wave);
    let spawnDelay = 0;
    waveData.enemies.forEach(enemyType => {
      setTimeout(() => {
        if (gameRunning) {
          enemies.push(new Enemy(enemyType));
        }
      }, spawnDelay);
      spawnDelay += Math.max(600 - wave * 20, 200);
    });
    updateWavePreview();
  }
  
  function getWaveData(waveNum) {
    const data = { enemies: [] };
    for (let i = 0; i < Math.min(waveNum + 3, 15); i++) {
      data.enemies.push('basic');
    }
    if (waveNum >= 1) {
      for (let i = 0; i < Math.floor(waveNum * 1.5); i++) {
        data.enemies.push('swarm');
      }
    }
    if (waveNum >= 2) {
      for (let i = 0; i < Math.floor(waveNum / 2); i++) {
        data.enemies.push('fast');
      }
    }
    if (waveNum >= 3) {
      for (let i = 0; i < Math.floor(waveNum / 3); i++) {
        data.enemies.push('flying');
      }
    }
    if (waveNum >= 4) {
      for (let i = 0; i < Math.floor(waveNum / 4); i++) {
        data.enemies.push('tank');
      }
    }
    if (waveNum >= 5) {
      for (let i = 0; i < Math.floor(waveNum / 5); i++) {
        data.enemies.push('worm');
      }
    }
    if (waveNum >= 6) {
      for (let i = 0; i < Math.floor(waveNum / 6); i++) {
        data.enemies.push('spider');
      }
    }
    if (waveNum >= 7) {
      for (let i = 0; i < Math.floor(waveNum / 7); i++) {
        data.enemies.push('shield');
      }
    }
    if (waveNum % 5 === 0) {
      data.enemies.push('boss');
    }
    if (waveNum % 10 === 0) {
      data.enemies.push('mega');
    }
    return data;
  }
  
  function updateWavePreview() {
    const waveData = getWaveData(wave + 1);
    const preview = document.getElementById('wavePreview');
    const counts = {};
    waveData.enemies.forEach(type => {
      counts[type] = (counts[type] || 0) + 1;
    });
    let text = '';
    Object.entries(counts).forEach(([type, count]) => {
      const name = enemyTypes[type].name;
      text += `${enemyTypes[type].emoji} ${name} x${count}<br>`;
    });
    preview.innerHTML = text || 'No enemies';
  }
  
  function updateUI() {
    document.getElementById('money').textContent = money;
    document.getElementById('health').textContent = health;
    document.getElementById('wave').textContent = wave;
    document.getElementById('score').textContent = score;
    document.getElementById('kills').textContent = kills;
    // Update tower buttons
    Object.keys(towerTypes).forEach(type => {
      const btn = document.getElementById(type + 'Tower');
      if (btn) {
        btn.disabled = money < towerTypes[type].cost;
      }
    });
  }
  
  // Mouse move tracking
  document.getElementById('gameCanvas').addEventListener('mousemove', (e) => {
    const rect = e.target.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
  });
  
  // Main game loop
  function gameLoop(timestamp) {
    if (!gameRunning || gamePaused) {
      requestAnimationFrame(gameLoop);
      return;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw background
    const gradient = ctx.createRadialGradient(400, 250, 0, 400, 250, 500);
    gradient.addColorStop(0, '#98fb98');
    gradient.addColorStop(0.5, '#90ee90');
    gradient.addColorStop(1, '#7cfc00');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // Grass texture
    ctx.fillStyle = '#228b2244';
    for (let i = 0; i < 50; i++) {
      const x = (i * 37) % canvas.width;
      const y = (i * 23) % canvas.height;
      ctx.fillRect(x, y, 2, 8);
      ctx.fillRect(x + 5, y + 3, 2, 6);
    }
    // Draw path
    drawPath();
    // Ghost tower preview
    if (selectedTowerType && !sellMode) {
      drawGhostTower(mouseX, mouseY);
    }
    // Update and draw towers
    towers.forEach(tower => {
      tower.update(timestamp);
      tower.draw();
    });
    // Update and draw enemies
    enemies = enemies.filter(enemy => {
      enemy.update(timestamp);
      enemy.draw();
      if (enemy.reachedEnd()) {
        health -= (enemy.type === 'mega' ? 5 : enemy.type === 'boss' ? 3 : 1);
        updateUI();
        return false;
      }
      return enemy.health > 0;
    });
    // Projectiles
    updateProjectiles(timestamp);
    drawProjectiles();
    // Particles
    updateParticles();
    drawParticles();
    // Effects
    updateEffects();
    drawEffects();

    // Check game over
    if (health <= 0) {
      alert(`🎮 GAME OVER! 🎮\n\n` +
            `📊 Final Statistics:\n` +
            `• Score: ${score.toLocaleString()}\n` +
            `• Waves Survived: ${wave - 1}\n` +
            `• Total Kills: ${kills}\n` +
            `• Towers Built: ${towers.length}\n\n` +
            `🏆 ${getPerformanceRating()}\n\n` +
            `Thanks for defending the lettuce farm!`);
      location.reload();
      return;
    }

    if (enemies.length === 0 && gameRunning) {
      // Wave complete
      const bonus = 25 + (wave * 8);
      money += bonus;
      wave++;
      gameRunning = false;
      effects.push({
        x: canvas.width / 2,
        y: canvas.height / 2,
        type: 'waveComplete',
        life: 120,
        maxLife: 120
      });
      updateUI();
      updateWavePreview();
    }
    requestAnimationFrame(gameLoop);
  }

  function getPerformanceRating() {
    if (wave >= 20) return "🏆 LETTUCE LEGEND! Incredible defense!";
    if (wave >= 15) return "🥇 SNAIL MASTER! Outstanding work!";
    if (wave >= 10) return "🥈 GARDEN HERO! Great job!";
    if (wave >= 5) return "🥉 PEST CONTROLLER! Good effort!";
    return "🌱 ROOKIE FARMER! Keep practicing!";
  }

  // Event handlers for buttons and interaction
  document.getElementById('startWaveBtn').onclick = () => {
    if (!gameRunning) {
      gameRunning = true;
      spawnWave();
    }
  };
  document.getElementById('pauseBtn').onclick = () => {
    gamePaused = !gamePaused;
    document.getElementById('pauseBtn').textContent = gamePaused ? '▶️ Resume' : '⏸️ Pause';
  };
  document.getElementById('speedBtn').onclick = () => {
    gameSpeed = gameSpeed === 1 ? 2 : gameSpeed === 2 ? 3 : 1;
    document.getElementById('speedBtn').textContent = `⚡ Speed: ${gameSpeed}x`;
  };
  document.getElementById('sellBtn').onclick = () => {
    sellMode = !sellMode;
    document.getElementById('sellBtn').textContent = sellMode ? '❌ Exit Sell' : '💰 Sell Mode';
    if (sellMode) {
      selectedTowerType = null;
      document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected-tower'));
    }
  };

  // Tower selection
  Object.keys(towerTypes).forEach(type => {
    const btn = document.getElementById(type + 'Tower');
    if (btn) {
      btn.addEventListener('click', () => {
        if (sellMode) {
          sellMode = false;
          document.getElementById('sellBtn').textContent = '💰 Sell Mode';
        }
        document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected-tower'));
        if (selectedTowerType === type) {
          selectedTowerType = null;
        } else {
          selectedTowerType = type;
          btn.classList.add('selected-tower');
        }
      });
    }
  });

  // Canvas click to place/sell
  document.getElementById('gameCanvas').addEventListener('click', (e) => {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (sellMode) {
      // Sell tower
      for (let i = towers.length - 1; i >= 0; i--) {
        const tower = towers[i];
        if (Math.hypot(x - tower.x, y - tower.y) < 25) {
          money += tower.getSellValue();
          towers.splice(i, 1);
          updateUI();
          break;
        }
      }
      return;
    }
    if (!selectedTowerType) return;
    // Check valid placement
    let validPosition = true;
    for (let pathPoint of path) {
      if (Math.hypot(x - pathPoint.x, y - pathPoint.y) < 45) {
        validPosition = false;
        break;
      }
    }
    for (let tower of towers) {
      if (Math.hypot(x - tower.x, y - tower.y) < 40) {
        validPosition = false;
        break;
      }
    }
    if (validPosition && money >= towerTypes[selectedTowerType].cost) {
      towers.push(new Tower(x, y, selectedTowerType));
      money -= towerTypes[selectedTowerType].cost;
      updateUI();
    }
  });

  // Initialize
  updateUI();
  updateWavePreview();
  requestAnimationFrame(gameLoop);
})();
  
const supportBtn = document.getElementById('support');
if (supportBtn) {
  supportBtn.addEventListener('click', () => {
    // Remove any 'selected-tower' highlights from other buttons
    document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected-tower'));
    // Toggle support selection
    if (selectedTowerType === 'support') {
      selectedTowerType = null; // Deselect if already selected
    } else {
      selectedTowerType = 'support'; // Select support tower
      supportBtn.classList.add('selected-tower');
    }
  });
}  
</script>

</body>
</html>
